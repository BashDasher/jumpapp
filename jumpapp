#!/usr/bin/env bash

show_usage() {
    local cmd=$(basename "${BASH_SOURCE[0]}")
    echo "Usage: $cmd [OPTION]... COMMAND [ARG]...

Jump to (focus) the first open window for an application, if it's running.
Otherwise, launch COMMAND (with opitonal ARGs) to start the application.

Options:
  -c NAME -- find window using NAME as WM_CLASS (instead of COMMAND)
  -f      -- force COMMAND to launch if process found but no windows found
  -i NAME -- find process using NAME as the command name (instead of COMMAND)
  -n      -- do not fork into background when launching COMMAND"
}

main() {
    local classid cmdid force fork=1
    while getopts c:fhi:n opt; do
        case "$opt" in
            c) classid="$OPTARG" ;;
            f) force=1 ;;
            h) show_usage; exit 0 ;;
            i) cmdid="$OPTARG" ;;
            n) fork='' ;;
        esac
    done

    shift $(( OPTIND - 1 ))
    OPTIND=1

    if (( ! $# )); then
        show_usage
        exit 0
    fi

    local cmd=$1
    shift

    check_for_prerequisites &&

    classid="$classid" cmd="$cmd" cmdid="$cmdid" force="$force" fork="$fork" \
        jumpapp "$@"
}

check_for_prerequisites() {
    if ! has_command wmctrl; then
        die 'Error: wmctrl(1) can not be found. Please install it to continue.'
    fi
}

jumpapp() {
    if [[ -z "$cmdid" ]]; then
        local cmdid=$(basename "$cmd")
    fi

    if [[ -z "$classid" ]]; then
        local classid=$cmdid
    fi

    local pids=( $(list_pids_for_command "$cmdid") )
    local windowids=( $(list_matching_windowids "$classid" "${pids[@]}") )

    if (( ${#windowids[@]} )); then
        activate_window "$(get_next_window "${windowids[@]}")" ||
            die "Error: unable to focus window for '$cmdid'"
    else
        if (( ${#pids[@]} )) && [[ -z "$force" ]]; then
            die "Error: found running process for '$cmdid', but found no window to jump to"
        else
            launch_command "$@"
        fi
    fi
}

list_matching_windowids() {
    list_windows | select_local_windows "$(get_hostname)" | select_windowid_by_class_or_pid "$@"
}

select_local_windows() {
    while read -r windowid hostname rest; do
        if [[ "$hostname" == "$1" ]]; then
            printf '%s\n' "$windowid $rest"
        fi
    done
}

select_windowid_by_class_or_pid() {
    local target_class=$1
    shift

    local windowid desktop class pid
    while read -r windowid desktop class pid; do
        if equals_case_insensitive "$class" "$target_class"; then
            printf '%s\n' "$windowid"
            continue
        fi
        for target_pid in "$@"; do
            if (( pid == target_pid )); then
                printf '%s\n' "$windowid"
                continue
            fi
        done
    done
}

get_next_window() {
    local first=$1

    local active=$(get_active_windowid)
    while [[ "$1" ]] && (( $1 != active )); do
        shift
    done
    shift # get windowid *after* active

    if [[ "$1" ]]; then
        printf '%s\n' "$1"
    else
        printf '%s\n' "$first"
    fi
}

launch_command() {
    has_command "$cmd" ||
        die "Error: unable to find command '$cmd'"

    printf 'Launching: %s\n' "$cmd $*"

    if [[ "$fork" ]]; then
        fork_command "$cmd" "$@"
    else
        exec_command "$cmd" "$@"
    fi
}

basename() {
    printf '%s\n' "${1##*/}"
}

equals_case_insensitive() {
    [[ "${1^^}" == "${2^^}" ]]
}


##### Concrete Implementation #####

# list_pids_for_command -- list all pids that have a matching argv[0]
#     A note on argv[0]: it's just a convention, not a kernel enforced value!
#     Programs are free to set it as they want, and so of course they do, ugh.
#     Some include the full path, others just the program name. Some
#     confusingly include all arguments in argv[0] (I'm looking at you
#     chromium-browser).
list_pids_for_command() {
    if has_command pgrep; then
        list_pids_for_command_with_pgrep "$@"
    else
        list_pids_for_command_from_procfs "$@"
    fi
}

list_pids_for_command_with_pgrep() {
    pgrep -f "^(/.*/)?$1\b"
}

list_pids_for_command_from_procfs() {
    for path in /proc/*/cmdline; do
        read -rd '' cmd_argv0 <"$path"
        local cmd=${cmd_argv0##*/} # substring removal in-lined for performance
        if [[ "$cmd" == "$1"* ]]; then
            basename "${path%%/cmdline}"
        fi
    done
}

list_windows() {
    while read -r windowid desktop pid wm_class hostname title; do
        printf '%s\n' "$windowid $hostname $desktop ${wm_class##*.} $pid"
    done < <(wmctrl -lpx)
}

get_active_windowid() {
    read name windowid < <(xprop -root ' $0\n' _NET_ACTIVE_WINDOW)
    printf '%s\n' "$windowid"
}

activate_window() {
    wmctrl -i -a "$1"
}

has_command() {
    hash "$1" 2>/dev/null
}

fork_command() {
    ("$@" >/dev/null 2>&1) &
}

exec_command() {
    exec "$@"
}

get_hostname() {
    hostname --short
}

die() {
    printf '%s\n' "$1" >&2
    exit 1
}

is_script_executed() {
    [[ "${BASH_SOURCE[0]}" == "$0" ]]
}

if is_script_executed; then
    main "$@"
fi
